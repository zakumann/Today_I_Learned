# 객체

## 객체 생성하기

### 객체의 생성

자바스크립트의 객체는 이름과 값을 한 쌍으로 묶은 집합이다. 이름과 값이 한 쌍을 이룬 것을 프로퍼티라고 한다. 혹은 키라고 불리기도 한다. 값으로는 모든 데이터 타입의 데이터(원시 값, 객체)를 저장할 수 있으며, 함수의 참조를 값으로 가진 프로퍼티는 메서드라는 이름으로 불린다.

1. 객체 리터럴로 생성하는 방법

```
var card = { suit: "하트", rank:"A"};
```

2. 생성자로 생성하는 방법

```
function Card(suit,rank){
    this.suit = suit;
    this.rank = rank;
}
var card = new Card("하트","A");
```

3. Object.create로 생성하는 방법

```
var card = Object.create(Object.prototype.{
    suit: {
        value : "하트",
        writeable: true,
        enumerable: true,
        configurable: true
    },
    rank: {
        value: "A",
        writable: true,
        enumerable: true,
        configurable: true
    }
});
```

### 프로토타입

#### 생성자 안에서 메서드를 정의하는 방식의 문제점

생성자 안에서 this 뒤에 메서드를 정의하면 그 생성자로 생성한 모든 인스턴스에 똑같은 메서드가 추가된다. 따라서 메서드를 포함한 생성자로 인스턴스를 여러 개 생성하면 같은 작업을 하는 메서드를 인스턴스 개수만큼 생성하게 되며 결과적으로 그만큼의 메모리를 소비하게 된다.

#### 프로토타입 객체

자바스크립트에서는 함수도 객체이므로 함수 객체가 기본적으로 prototype 프로퍼티를 갖고 있다.

```
function f(){};
console.log(F.prototype);
```

프로토타입 객체의 프로퍼티는 읽기만 가능하고 수정이 불가능하다. 인스턴스의 프로퍼티에 값을 대입했을 때 이름이 값은 프로퍼티가 있으면 그 프로퍼티에 값을 대입한다. 그렇지 않을 때는 인스턴스에 그 이름으로 프로퍼티를 추가한 후에 값을 대입한다. 생성자 안에서 this 뒤에 메서드를 정의할 때 생기는 문제는 생성자의 프로토타입 객체에 메서드를 추가하는 방식으로 해결할 수 있다.

## 프로토타입 상속

### 상속

상속은 일반적으로 특정 객체가 다른 객체로부터 기능을 이어받는 것을 말한다. 자바스크립트에서는 클래스가 아닌 객체를 상속한다. 자바스크립트의 상속은 프로토타입 체인이라고 부르는 객체의 자료 구조로 구현되어 있으며, 프로토타입 상속으로 부른다. 자바스크립트에서는 생성자가 클래스의 역할을 하지만 생성자를 상속하기 위한 구문을 언어 차원에서 제공하지 않는다.

### 상속을 하는 이유

상속을 사용하면 이미 정의된 프로퍼티와 메서드의 코드르 재사용할 수 있고 새로운 기능을 추가해서 확장된 객체를만들 수도 있다. 중복 코드를 작성하지 않아도 되므로 유지 보수성이 높은 프로그램을 만들 수 있다.

### 프로토타입 체인

#### 내부 프로퍼티[[prototype]]

모든 객체는 내부 프로퍼티[[prototype]]을 가지고 있다. 이것은 함수 객체의 prototype 프로퍼티와는 다른 객체이다. ECMAScript 6부터는 __proto__프로퍼티에 [[prototype]]의 값이 저장된다.

#### 프로토타입 체인

객체의 __proto__ 프로퍼티는 그 객체에게 상속을 해 준 부모객체를가리킨다. 따라서 객체는 __proto__ 프로퍼티가 가리키는 부모객체의 프로퍼티를 사용할 수 있다. 프로토타입 체인은 객체의 연결 고리이다. 

프로토타입 상속을 하는 객체 지향 언어를 가리켜 프로토타입 기반 객체 지향 언어라고 한다.

### new 연산자의 역할

new 연산자와 생성자 함수
객체 리터럴 {...} 을 사용하면 객체를 쉽게 만들 수 있다. 그런데 개발을 하다 보면 유사한 객체를 여러 개 만들어야 할 때가 생기는 일이 있다. 복수의 사용자, 메뉴 내 다양한 아이템을 객체로 표현하려고 하는 경우가 있다.

'new' 연산자와 생성자 함수를 사용하면 유사한 객체 여러 개를 쉽게 만들 수 있다.

### 프로토타입 객체의 프로퍼티

함수를 정의하면 함수 객체는 기본적으로 prototype 프로퍼티를 가지게 된다. 그리고 이 prototype 프로퍼티는 프로토타입 객체를 가리키며, 이 프로토타입 객체는 기본적으로 constructor 프로퍼티와 내부 프로퍼티 [[Prototype]](__proto__)을 가지고 있다.

#### constructor 프로퍼티

constructor 프로퍼티는 함수 객체의 참조를 값으로 갖고 있다. 생성자와 생서자의 프로토타입 객체는 서로를 참조한다. 정확히는 '생성자의' prototype 프로퍼티가 프로토타입 객체를 가리키며, 이 프로토타입 객체의 constructor 프로퍼티가 생성자를 가리키는 연결 고리'로 묶여 있다. 반면 생성자로 생성한 인스턴스는 생성될 때의 프로토타입 객체의 참조만 가지고 있을 뿐 생성자와는 직접적인 연결 고리가 없다.

인스턴스가 어떤 생성자로 생ㅅ어된 것인지 알아내는 방법으로는 인스턴스가 가진 프로토타입의 constructor 프로퍼티 값을 확인하는 방법이 있다. 인스턴스는 프로토타입에서 constructor 프로퍼티를 상속받기 때문에 constructor 프로퍼티를 인스턴스의 프로퍼티로 참조 할 수 있다.

#### 내부 프로퍼티[[Prototype]]

함수 객체가 가진 프로토타입 객체의 내부 프로퍼티는 기본적으로 Object.prototype을 가리킨다. 즉, 프로토타입 객체의 프로토타입은 Object.prototype이다.

#### 프로토타입 객체의 교체 및 constructor 프로퍼티

생성자가 가진 prototype 프로퍼티 값을 새로운 객체로 교체할 때는 주의해야 할 점은 프로퍼티만 정의되어 있는 새로운 객체를 prototype 프로퍼티 값으로 대입하면 인스턴스와 생성자 사이의 연결 고리가 끊겨 버린다. 이는 그 객체에 constructor 프로퍼티가 없기 대문이다. 인스턴스와 생성자 사이의 연결 고리를 유지하려면 prototype으로 사용할 객체에 constructor 프로퍼티를 정의하고, 그 프로퍼티에 생성자의 참조를 대입해야 한다.

#### 인스턴스 생성 후에 생성자의 프로토타입을 수정하거나 교체한 경우

인스턴스를 생성한 후에 생성자의 prototype 프로퍼티 값을 다른 객체로 교체해도 인스턴스의 프로토타입은 바뀌지 않는다. 즉, 인스턴스의 프로퍼티는 생성되는 시점의 프로토타입에서 상속받는다.

### 프로토타입의 확ㅇ닌

특정 프로토타입 객체가 그 객체의 포로토타입 체인에 포함되어 있는지 확인하는 방법에는 instanceof 연산자나 isPrototypeOf 메서드를 이용하는 방법이 있다.

#### instanceof 연산자

instanceof 연산자는 지정한 객체의 프로토타입 체인에 지정한 생성자의 프로토타입 객체가 ㄹ포함되어 있는지 판정한다.

```
객체 instanceof 생성자
```

#### isPrototypeOf 메서드

isPrototypeOf 메서드는 특정 객체가 다른 객체의 프로토타입 체인에 포함되어 있는지 판정한다.
```
프로토타입객체.isPrototypeOf(객체)
```

### Object.prototype

#### Object생성자

Object 생성자는 내장 생성자로 일반적인 객체를 생성한다. Object 생성자를 인수 없이 실행하면 Object 생성자는 빈 객체를 생성한다.

```
var obj = new Object();
```

이는 객체 리터럴로 작성한 빈 객체와 완전히 같다.
```
var obj = {};
```

인수에 값을 지정하면 그 값을 Objewct 객체로 변환한 인스턴스를 생성한다.

```
var obj = new Object("ABC);
```

Object 생성자는 new 없이 호출해도 new를 붙여서 호출했을 때와 같은 방식으로 동작한다.

```
var obj = Object(); // var obj = new Object()와 같음
```

## 접근자 프로퍼티

접근자 프로퍼티를 사용하면 프로퍼티를 읽고 쓸 때 원하는 작업을 자동으로 처리할 수 있다.

### 프로퍼티의 종류

- 데이터 프로퍼티 : 값을 저장하기 위한 프로퍼티
- 접근자 프로퍼티 : 값이 없음. 프로퍼티를 읽거나 쓸 때 호출하는 함수를 값 대신에 짖어할수 있는 프로퍼티

### 접근자 프로퍼티

접근자란, 객체 지향 프로그래밍에서 객체가 가진 프로퍼티 값을 객체 바깥에서 읽거나 쓸 수 있도록 제공하는 메서드를 말한다. 객체의 프로퍼티를 객체 바깥에서 직접 조작하는 행위는 데이터의 유지 보수성을 해치는 주요한 원인이다. 자바스크립트의 접근자 프로퍼티는 객체에 접근자를 정의할 수 있게 한다. 접근자 프로퍼티를 사용하여 프로퍼티를 읽고 쓸 수 있게 하면 프로그램의 유지 보수성을 높일 수 있다.

접근자 프로퍼티 하나에 대해 그 프로퍼티를 읽을 때의 처리를 담당하는 게터 함수와 쓸 때의 처리를 담당하는 세터 함수를 정의할 수 있다. 접근자 프로퍼티는 게터와 세터 중에서 하나만 정의할 수도 있지만 모두 정의할 수도 있다.

접근자 프로퍼티에 게터와 세터를 정의하려면 function 키워드 대신 get이나 set 키워드를 사용한 함수를 작성한다. 게터에는 인수가 없고 세터는 인수를 한 개 받는다. 게터와 세터는 일반 함수와 마찬가지로 중괄호 안에 모든 처리를 작성할수 있다. 게터가 없는 접근자 프로퍼티를 읽으려고 시도하면 undefined가 반환된다. 세터가 없는 접근자 프로퍼티를 쓰려고 시도하면 아무것도 실행되지 않으며 제어권이 곧장 호출자에게 되돌아온다. Strict 모드에서 세터가 없는 접근자 프로퍼티를 쓰려고 시도하면ㅇ ㅗ류가 발 생한다.

## 프로퍼티의 속성

### 프로퍼티의 속성

프로퍼티는 프로퍼티의 이름과 값이 한 쌍을 이룬 것이지만 이와는 별개로 내부적인 속성을 몇 개 더 가지고 있다. ECMAScript 5부터는 쓰기 가능 여부와 재정의 가능 여부를 뜻하는 내부 속성 두 개, 접근자 프로퍼티, 내부 속성을 조작할 수 있는 수단이 추가되었다.

#### 쓰기 가능(writable)

프로퍼티에 쓰기가 가능한지를 뜻하는 속성이다. 이 속성 값이 true면 프로퍼티 값을 수정할 수 있다.

#### 열거 가능(enumerable)

프로퍼티가 for/in 문이나 Object.keys 등의 반복문으로 찾을 수 있는 대상인지를(열거 가능) 뜻하는 속성이다.

#### 재정의 가능(configurable)

프로퍼티의 내부 속성을 수정할 수 있는지를 뜻하는 속성이다. 이 속성 값이 true면 delete 연산자로 그 프로퍼티를 제거할 수 있으며 프로퍼티가 가진 내부 속성을 수정할 수 있다.

### 프로퍼티 디스크립터와 프로퍼티를 읽고 쓰는 메서드

프로퍼티의 속성은 프로퍼티 디스크립터(프로퍼티 기술자)로 설정할 수 있다.

#### 프로퍼티 디스크립터

프로퍼티 디스크립터는 프로퍼티의 속성 값을 뜻하는 객체이다. 이 객체가 가진 프로퍼티의 이름은 프로퍼티가 가진 속성 이름과 같다.

```
    value: 프로퍼티의 값,
    writeable: 논리값,
    enumerable: 논리값,
    configurable: 논리값
```

접근자 프로퍼티의 프로퍼티 디스크립터는 다음 네 개의 프로퍼티를 가진 객체이다.
```
    get: getter함수값,
    set: setter함수값,
    enumerable: 논리값,
    configurable: 논리값
```

## 프로퍼티가 있는지 확인하기 

### in 연산자

in 연산자는 객체 안에 지명한 프로퍼티가 있는지 검색하며, 그 검색 대상은 극 ㅐㄱ체가 소유한 프로퍼티와 상속받은 프로퍼티 모두이다.

```
var person = {name : "Tom};
console.log("name" in person);
console.log("age" in person);
console.log("toString" in person);
```

### hasOwnProperty 메서드

hasOwnProperty 메서드는 지명한 프로퍼티가 그 객체가 소유한 프로퍼티면 true를 반환하고 상속 받은 프로퍼티면 false를 반환한다.

```
var person = { name: "Tom"};
console.log(person.hasOwnProperty("name));
console.log(person.hasOwnProperty("toString"));
```

### propertyIsEnumerable 메서드

propertyIsEnumerable 메서드는 지정한 프로퍼티가 그 객체가 소유한 프로퍼티이며 열거할수 있을 때 true를 반환한다.

```
var person1 = { name: "Tom", age: 17 };
var person2 = Object.create(person1);
person2.name = "Huck";
console.log(person2.propertyIsEnumerable("name"));
console.log(person.propertyIsEnumerable("age"));
console.log(Object.prototype.propertyIsEnumerable("toString"));
```

## 프로퍼티의 열거

### for/in 문

for/in 문은 객체와 객체의 프로토타입 체인에서 열거할 수 있는 프로퍼티를 찾아내어 꺼내는 반복문이다.
```
var person1 = { name: "Tom", age: 17 };
var person2 = Object.create(person1);
person2.name = "Huck";
for(var p in person2) console.log(p);
```
앞 코드의 person2 객체가 사용할 수 있는 프로퍼티는 이 객체가 소유한 프로퍼티인 name.person1에서 상속받은 프로퍼티인 name과 age이다. 물론, Object.prototype에서 상속받은 toString 등의 프로퍼티도 사용할 수 있다. 이때 eprson2 객체는 person1 객체에서 상속받은 name 프로퍼티 대신 객체 자신이 소유한 name 프로퍼티를 사용하게 된다. Object.prototype의 프로퍼티는 열거할 수 없으므로 for/in 문으로는 찾아낼 수 없다.

### Object.keys 메서드

해당 객체가 소유한 프로퍼티 이름만 조회하는 용도로는 Object.keys 메서드가 쓰인다.

```
var p = Object.keys(obj);
for(var i=0; i<p.length; i++){
    console.log(obj[p[i]]);
}
```

### Object.getOwnPropertyNames 메서드

Object.getOwnPropertyNames 메서드도 인수로 지정한 객체가 소유한 프로퍼티 이름을 배열로 만들어 변환한다. 그때 열거 할 수 있는 프로퍼티와 열거할 수 없는 프로퍼티의 이름을 모두 배열로 만드는 점이 특징이다.

## 객체 잠그기

객체를 잠글 때는 객체의 확장 가능 속성, 재정의 가능 속성, 쓰기 가능 속성을 설정한다. ECMASciprt 5부터 이속성을 한꺼번에 설정할 수 있는 메서드가 추가되었으며 잠금 강도에 따라 3단계 잠금이 가능해졌다.

### 확장 방지 : Object.preventExtensions 메서드

object.preventextensions 메서드는 인수로 받은 객체를 확장할 수 없게 만든다. 이 메서드로 확장할 수 없게 만든 객체는 두 번 다시 프로퍼티를 추가할 수 없게 된다. 

### 밀봉 : Object.seal 메서드

Object.seal 메서드는 인수로 받은 객체를 밀봉한다. 밀봉이란 객체에 프로퍼티를 추가하는 것을 금지하고 기존의 몯느 프로퍼티를 재정의 할 수없게 만드는 것을 말한다. 다시 말해 객체를 밀봉하면 프로퍼티의 추가, 삭제, 수정을 할 수 없고 값의 읽기와 쓰기만 가능해진다.

### 동결 : Object.freeze 메서드

Object.freeze 메서드는 인수로 받은 객체를 동결한다. 동결이란객체에 프로퍼티를 추가하는 것을 금지하고 기존의 모든 프로퍼티를 재정의 할 수 없게 만들며 데이터 프로퍼티를 쓸 수 없게 만드는 것이다. 다시 말해 객체를 동결하면 객체의 프로퍼티가 읽기만 가능한 상태가 된다. 단, 객체에 접근자 프로퍼티가 정의되어 있담녀게터 함수와 세터 함수 모두를 호출할 수 있다.

## Mixin

### Mixin 함수

믹스인이란 특정 객체에 다른 객체가 가지고 있는 프로퍼티를 붙여 넣어 '뒤섞는' 기법을 말한다. 믹스인은 상속을 사용하지 않는 대신 특정 객체의 프로퍼티를 동적으로 다른객체에 추가한다.

## JSON

### JSON

JSON(JavaScript Object Notation)은 자바스크립트 객체를 문자열로 표현하는 데이터 포맷이다. JSON을 사용하면 직렬화할 수 있다. 직렬화란 컴퓨터의 메모리 속에 있는 개체를 똑같은 객체로 환원할 수 있는 문자열로 변환하는 과정을 말한다.

- 숫자 : 정수와 부동소수점의 10진수 표기만 가능하다. 부동소수점은 지수 표기법도 사용할 ㅅ수 있다.
- 문자열 : 큰따옴표로 묶어야 한다. 이스케이프 시퀀스도 포함 할 수 있다.
- 논리값 : true 또는 false
- null 값 
- 배열 : 모든 데이터 타입을 배열의 요소로 사용할 수 있다.
- 객체 : 프로퍼티 이름은 큰따옴표로 묶은 문자열로 표기한다.

### JSON의 변환과 환원

JSON.stringify 메서드는 인수로 받은 객체를 JSON 문자열로 바꾸어 변환한다.

```
JSON.stringify(value[, replacer[, space]])
```

#### JSON 문자열을 자바스크립트 객체로 환원하기 : JSON.parse

JSON.parse 메서드는 인수로 받은 문자열을 자바스크립트 객체로 환원하여 반환한다.

```
JSON.parse(text[, reviver])
```