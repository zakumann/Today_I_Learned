## 클로저

클로저는 자바스크립트가 가진 강력한 기능으로, 이를 활용하면 변수를 은닉하여 지속성을 보장하는 등의 다양한 기능을 구현할 수 있다. 자바스크립트는 스킴이라는 언어에서 큰 영향을 받았다.

클로저를 프로그래밍 언엊겅니 고나점에서 설명하면

> 자기 자신이 정의한 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행한다.

### 클로저의 성질

```
function makeCounter(){
    var count = 0;
    return f;
    function f(){
        return count++;
    }
}
var counter = makeCounter();
console.log(counter());
console.log(counter());
console.log(counter());
```
카운터 함수를 만든느 함수이 예제에서는 counter()를 호출할 때마다 함수 makeCounter의 지역 변수인 count 값을 출력한 후에 count 값을 1씩 증가시킨다.

자바스크립트 클로저는 함수의 일급 객체 성질을 이용한다. 함수가 생성될 때, 함수 내부에서 사용되는 변수들이 외부에 존재하는 경우 그 변수들은 함수의 스코프에 저장한다. 따라서 스코프에 따라서 변수가 영향을 받는다.

그리고, 객체의 프로퍼티를 외부에서 읽고 쓸 수 있지만 클로저 내부 상태는 외부로부터 숨겨진 상태이다. 객체 지향 프로그래밍에서는 객체의 프로퍼티를 외부로부터 은폐하는 행위를 가리켜 캡슐화라고 한다. 즉, '클로저는 캡슐화된 객체'라고 할 수 있다.

[JavaScript 클로저](https://velog.io/@sxxng_ju/JavaScript-%ED%81%B4%EB%A1%9C%EC%A0%80Closure#:~:text=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%ED%81%B4%EB%A1%9C%EC%A0%80%EB%8A%94%20%ED%95%A8%EC%88%98,%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84%EC%97%90%20%EC%A0%80%EC%9E%A5%ED%95%9C%EB%8B%A4.&text=%EB%94%B0%EB%9D%BC%EC%84%9C%20%EC%8A%A4%EC%BD%94%ED%94%84%EC%97%90%20%EB%94%B0%EB%9D%BC%EC%84%9C%20%EB%B3%80%EC%88%98%EA%B0%80%20%EC%98%81%ED%96%A5%EC%9D%84%20%EB%B0%9B%EB%8A%94%EB%8B%A4.)

## 이름 공간

### 전역 이름 공간의 오염

전역 변수와 전역 함수를 전역 객체에 선언하는 행위를 가리켜 '전역 유효 범위를 오염시킨다.'고 한다. 전역 유효 범위가 오염되면 다음과 같은 상황일 때 변수 이름과 함수 이름이 겹칠 수 있다.

- 라이브러리 파일을 여러 개 읽어 들여 사용할 때
- 규모가 큰 프로그램을 만들 때
- 여러 사람이 한 프로그램을 만들 때

### 전역 변수의 오염을 방지하기 위한 방법

1. 객체를 이름 공간으로 활용하기

**이름 공간**이란 변수 이름과 함수 이름을 한 곳에 모아 두어 이름 충돌을 미리 방지하고, 변수와 함수를 쉽게 가져다 쓸 수 있게 만든 매커니즘이다.

객체를 이름 공간으로 활용하려면 객체를 값으로 가지는 전역 변수를 하나 생성하고, 그 객체에 프로그램 전체에서 사용하는 모든 변수와 함수를 프로퍼티로 정의한다.

```
var myApp = myApp || {};
```

이렇게 작성해 두면 myApp이 이미 정의되어 있을 때는 그것을 사용하고 그렇지 않으면 빈 객체를 myApp에 할당한다. 이 객체에 전역 유효 범위에서 사용하고자 하는 모든 변수와 함수를 프로퍼티로 추가해 본다.

```
myApp.name = "Tom";
myApp.showName = function(){ ... };
...
```

이렇게 되면 myApp만이 사용자가 정의한 전역 변수가 되므로 전역 유효 범위의 오염을 최소화 할 수 있다. 또한, **부분 이름 공간**을 만들 수 도 있다.

```
myApp.view.draw = function(){ ... };
myApp.controls.timeInterval = 16;
```

이처럼 객체를 이름 공간으로 이용하면 변수 또는 함수 이름을 계층적으로 관리 할 수 있다.

2. 함수를 이름 공간으로 활용하기

함수 안에서 선언된 변수의 유효 범위는 함수 내부이다. 따라서 그 변수를 함수 안에서는 읽거나 쓸 수 있지만 바깥에서는 읽거나 쓸 수없다. 이 성질을 활용하면 함수를 이름 공간으로 활용 할 수 있다.

```
var x = "global x";
(function(){
    var x = "local x";
    var y = "local y";
})();
console.log(x);
console.log(y);
```

즉시 실행 함수 내부에서 선언한 변수인 x와 y는 이 함수의 지역 변수이므로 전역 변수와 이름이 충돌하지 않는다. 따라서 일시적인 처리를 수행하고자 할 때 그 내용물을 즉시 실행 함수 안에 작성하면 전역 유효 공간을 전혀 오염시키지 않는다.

**모듈 패턴**

모듈은 기능(함수) 여러 개를 하나로 묶은 것이다. 모듈은 함수 여러 개와 함수가 공유하는 데이터로 구성된다. 모듈을 다양한 프로그램에서 사용하면 모듈 안에서 사용하는 변수 이름이나 함수 이름이 모듈을 사용하는 프로그램의 변수 이름이나 함수 이름과 충돌할 가능성이 있다. 이때 모듈을 즉시 실행 함수 안에 작성하여 실행하면 이름이 충돌하는 상황을 피할 수 있다. 하지만 즉시 실행 함수의 내부에 작성한 함수나 변수는 프로그램 바깥에서는 사용 할수 없다. 그래서 즉시 실행 함수에 객체로 구현한 이름 공간을 전역 변수로 넘겨서 공개할 함수를 이름 공간에 추가하도록 한다.

## 객체로서의 함수

### 함수는 객체

자바스크립트의 함수는 Function 객체이다. 아래는 특징이다.

- 함수는 변수나 프로퍼티나 배열 요소에 대입할 수 있다.
- 함수는 함수의 인수로 사용할 수 있다.
- 함수는 함수의 반환값으로 사용할 수 있다.
- 함수는 프로퍼티와 메서드를 가질 수 있다.
- 함수는 이름 없는 리터럴로 표현할 수 있다.(익명 함수)
- 함수는 동적으로 생성할 수 있다.

이러한 작업이 가능한 객체를 가리켜 일급 객체라고 한다. 일급 객체인 함수는 일급 함수라고 한다. 하지만, 자바스크립트의 함수는 일급 함수이지만 C나 java와 같은 프로그래밍 언어의 함수는 일급 함수가 아니다.

### 함수의 프로퍼티

caller : 현재 실행 중인 함수를 호출한 함수
length : 함수의 인자 개수
name : 함수를 표시할 때 사용하는 이름
prototype : 프로토타입 객체의 참조

apply() : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 배열 객체다.
bind() : 선택한 this와 인수를 적용한 새로운 함수를 반환한다.
call() : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 쉼표로 구분한 값이다.
constructor : Function 생성자의 참조
toString() : 함수의 소스 코드를 문자열로 만들어 반환한다.

### apply와 call 메서드

Function 객체의 메서드에서는 apply와 call이 있다. this 값과 함수의 인수를 사용하여 함수를 실행하는 메서드다. apply와 call의 동작은 본질적으로 같지만 차이점은 함수에 인수를 넘기는 방법뿐이다. apply의 인수는 배열이고 call의 인수는 쉼표로 구분한 값의 목록이다.

### bind 메서드

Functino 객체의 bind 메서드는 객체에 함수르 ㄹ바인드한다.

### 함수에 프로퍼티 추가하기

Function 객체에 추가된 프로퍼티는 그 함수를 실행하지 않아도 읽거나 쓸 수 있다. 함수의 프로퍼티에는 일반적으로 그 함수의 작업과 관련된 데이터와 메서드를 저장한다. 물론 전역 변수에 저장해도 같은 작업을 할 수 있다. 하지만 전역 변수를 사용하면 전역 유효 범위를 오염시켜 버리므로 변수 이름 충돌을 늘 경계해야 한다. 그러나 이를 함수의 프로퍼티로 작성하면 함수 객체가 이름 공간의 역할을 하기 때문에 문제가 발생하지 않는다. 

**메모이제이션**

메모이제이션은 함수를 호출했을 때의 인수와 반환값을 한 쌍으로 만들어 저장해 두는 기법을 말한다. 함수에 메모이 제이션을 적용해 두면 한 번 건네받은 이력이 있는 인수의 결과값으로 저장해 둔 결과를 반환하므로 추가적인 계싼을 생략할 수 있다. 메모이 제이션을 구사할 때 인수와 반환값을 저장하는 위치를 고르는 방법은 매우 다양하다.

## 고차 함수

### 고차 함수

고차 함수란 함수를 인수로 받는 함수 또는 함수를 반환하는 함수를 말한다. 자바스크립트의 함수는 일급 객체고 함수의 인수로 함수를 넘길 수 있으며 함수를 반환할 수 있으므로 고차 함수를 쉽게 정의할 수 있다. 고차 함수를 사용하면 처리 패턴이 같은 작업을 추상화하여 하나로 합칠 수 있다.

고차 함수는 함수형 프로그래밍을 할 때 자주 사용한다.

예)
```
function joinStrings(n,f){
    var s = "";
    for(var i=0; i<n; i++){
        s += f(i);
    }
    return s;
}
```

고차 함수 joinStrings를 사용해서 앞에서 작성한 두 함수와 똑같은 작업을 하는 함수를 생성하면 다음과 같은 모습이 된다.

```
var digits = joinStrings(10, function(i){ return i; });
var randomChars = joinStrings(8, function(i){
    return String.fromCharCode(Math.floor(Math.random()*26) + "a".charCodeAt(0));
});
console.log(digits);
console.log(randomChars);
```

### 메모이제이션

memorize 함수는 인수로 받은 함수의 실행 결과를 객체 cache 안에 저장한다. 이 덕분에 인수로 받은 함수를 같은 인수로 실행하면 실제 계산을 하는 대신 cache에 저장된 값을 반환하는 함수가 만들어진다. memorize 함수의 중첩 함수는 클로저를 생성한다. 따라서 memorize의 지역 변ㅅ구인 cache는 클로저 내부 상태로 저장된다.

또한 재귀 함수에 메모이제이션을 적용하려면 원래 함수를 재귀 호출하는 대신 메모이 제이션된 함수를 재귀 호출하도록 만들어야 한다.

### 함수의 합성

함수 f(x)와 g(x)가 있을 때 함수 f(g(x))를 f와 g의 합성 함수라고 한다.

```
function compose(f,g){
    return function(x){
        return f(g(x));
    };
}
```

### 부분 적용

인수를 여러개 받는 함수의 몇몇 인수를 상수로 지정해서 새로운 함수를 생성하는 기법을 말한다.

```
function product(x, y){ return x * y; }
```
이 함수 product(x, y)의 인수를 부분 적용한 함수인 product2(x)는 다음과 같이 정의한다.

```
product2 = function(y){ return product(2, y); };
product2(3);
```

bind 메서드를 사요하면 앞 코드를 다음과 같이 바꾸어 쓸 수 있다.

```
product2 = product.bin(null, 2);
```

코드를 이렇게 수정하면 bind 메서드의 두 번째 이후 인수가 원래 함수의 인수에 왼쪽부터 오른쪽으로 할당된다. 그러면 함수 product에 인수를부분 적용한 함수인 product2가 만들어진다.

### 커링

커링이란 인수를 두 개 이상 받는 함수를 분해하여 인수가 하나인 함수의 중첩 함수로 변환하는 작업을 말한다.

```
var pow = function(exponent){
    return function(base){
        return Math.pow(base, exponent);
    };
};
```
이렇게 정의한 함수 pow는 Math.pow를 커링한 것이다.

```
Math.pow(base, exponent) = pow(exponent)(base)
```
커링된 함수의 가장 큰 장점은 부분 적용한 함수를 쉽게 만들어 낼 수 있다는 점이다.

```
var square = pow(2);
var sqrt = pow(.5);
var cubicroot = ppow(1/3);
```
이렇게 하면 Math.pow를 부분 적용한 함수인 square, sqrt, cubicroot를 만들 수 있다.

## 콜백 함수

### 콜백 함수

콜백 함수는 함수를 호출할 때 뭉넉 ㅏ새로운 일이 생기거나 그 함수의 실행이 끝나면 지정한 콜백 함수를 실행해 주도록 함수에 요청해야 할 때 사용한다. 이때 콜백 함수의 주체는 어디까지나 함수를 호출한 호출자이다. 호출자가 목적에 따라 어떠한 콜백 함수를 사용할 것인지 정한다. 호출된 함수는 콜백 함수를 실행하지만 그 콜백 함수가 작엉하는 내용에는 관여하지 않는다.

### 이벤트 처리기

이벤트 처리기는 특정 이벤트가 발생했을 때 실행하도록 등록하는 함수이다.

```
button.onclick = function(){ ... };
```

이는 함수를 호출할 때 무언가 사건이 발생하면 콜백 함수를 실행하도록 인수로 넘기는 행위와 닮았다.

### 타이머

타이머 메서드(setTimeout, setInterval)에 첫 번째 인수로 넘기는 함수가 바로 콜백 함수이다.

```
setInterval(function(){ ... }, 2000);
```