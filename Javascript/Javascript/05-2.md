## 비트 연산

비트 연산은 2진수 숫자의 자리별 값을 다루는 연산이다.

비트 연산자는 피연산자를 부호 있는 32비트 정수로 변환해서 처리한다. 비트 연산자에는 비트 논리 연산자와 비트 시프트 연산자가 있따. 모든 비트 연산자에는 대입 연산자를 사용할 수 있다.

### 비트 논리 연산자

비트 논리 연산자는 비트 값이 0이면 false, 1이면 true로 평가하는 여산자이다.

& : 비트 논리곱(AND)
| : 비트 논리합(OR)
^ : 비트 배타적 논리합(XOR)
~ : 비트 논리 부정(NOT)

### 비트 시프트 연산자

<< : 왼쪽 시프트

>> : 부호 있는 오른쪽 시프트

>>> : 부호 없는 오른쪽 시프트

### 비트 연산의 대입 연산자

|연산자| 예제| 예제의 뜻|
|-----|-----|---------|
|&=|a &= b | a = a & b |
|'|='| a '|=' b | a = a '|' b |
|^=| a ^= b | a = a ^ b|
|<<=|a <<= n | a = a << n |
|>>=| a >>= n | a = a >> n |
|>>>=| a >>>= n | a = a >>> n |

## 기타 연산

기타 연산자

|연산자| 뜻|
|-----|-----|
|typoeof|데이터 타입을 조사한다.|
|?:|조건 연산자|
|void|정의되지 않은 값을 반환한다.|
|,|왼쪽에서 오른쪽 순서대로 피연산자를 연속해서 실행한다.|
|delete|객체의 프로퍼티나 배열 요소를 제거한다.|
|new|새로운 객체를 생성한다.|
|in|객체의 프로퍼티 포함 여부를 확인한다.|
|instanceof|객체의 종류를 확인한다.|
|eval()|인수로 받은 문자열을 자바스크립트 코드로 실행한다.|

typeof 연산자

|데이터|typeof 연산자의 반환값|
|-----|----------------------|
|숫자, NaN|"number"|
|문자열|"string"|
|논리값|"boolean"|
|정의되지 않은 값|"undefined"|
|null 값|"object"|
|심볼|"symbol"|
|회의 외의 객체|"object"|
|함수|"function"|

- 조건 연산자

조건 연산자는 주어진 조건의 참과 거짓에 따라 값을 선택한다.

- 쉼표 연산자

쉼표 연산자는 이항 연산자로 왼쪽 피연산자를 평가하고 오른쪽 피연산자를 평가한 이후에 마지막으로 오른쪽 끝 피연산자의 값을 반환한다.

- eval 함수

evalㅎ은 함수일 뿐 연산자는 아니지만 연산자의 역할을 담당하고 있었다. eval 함수는 문자열 단 하나만을 인수로 받아서 자바스크립트 코드로 해석한다. 문자열을 해석할 때는 코드를 평가한 후에 마지막 표현식 또는 문장의 값을 반환한다.

### 명시적 타입 변환

명시적 타입 변환
개발자의 의도에 의해 명시적으로 타입을 변경하는 방법은 다양하다. 원래는 래퍼 객체를 생성하기 위해 사용하는 래퍼 객체 생성자 함수를 new 연산자 없이 호출하는 방법과 자바스크립트에서 제공하는 빌트인 메소드를 사용하는 방법, 그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.

#### 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법

1. String 생성자 함수를 new 연산자 없이 호출하는 방법
2. Object.prototype.toString 메소드를 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법

#### 숫자 타입으로 변환

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법

1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
3. 단항 연결 연산자를 이용하는 방법
4. 산술 연산자를 이용하는 방법

#### 불리언 타입으로 변환

불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법

1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
2. ! 부정 논리 연산자를 두번 사용하는 방법

