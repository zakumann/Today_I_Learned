# 함수

## 함수 정의하기

### 함수를 정의하는 방법

1) 함수 선언문으로 정의하는 방법

2) 함수 리터럴로 정의하는 방법

3) Function 생성자로 정의하는 방법

4) 화살표 함수 표현식으로 정의하는 방법

### 중첩 함수

특정 함수의 내부에 선언된 함수를 중첩 함수라고 한다. 중첩 함수를 지역 함수 또는 내부 함수라고 부르기도 한다. 자바스크립트에서는 외부 함수의 최상위 레벨에만 중첩 함수를 작성할 수 있다. 단, if 문과 while 문 등의 문장 블록 안에는 중첩 함수를 작성할 수 없다.

## 함수 호출하기

### 함수를 호출하는 방법

1) 함수 호출

2) 메서드 호출

3) 생성자 호출

4) call, apply를 사용한 간접 호출

### 즉시 실행 함수

익명 함수의 참조를 변수에 할당한 후에 그룹 연산자인 ()를 붙여서 실행한다.

```
var f = function(){...};
f();
```

```
(function(){...})();
```

or

```
(function(){...}());
```

즉시 실행 함수를 정의하는 방법

## 함수의 인수

### 인수의 생략

함수 정의식에 작성된 인자 개수보다 인수를 적게 전달해서 함수를 실행하면 인수에서 생략한 인자는 undefined가 된다.

호출할 때 인수를 생략할 수 있는 함수를 정의할 수 있다.

### 가변 길이 인수 목록(Arguments 객체)

모든 함수에서 사용할 수 있는 지역 변수로는 arguments 벼눗가 있다.

```
arguments[0] : 첫 번째 인수 값
arguments[1] : 두 번째 인수 값

...

arguments[n-1] : n번째 인수 값
```

Arguments 객체는 프로퍼티로 length와 callee를 갖고 있으며 각 프로퍼티에는 다음과 같은 갑싱 담겨 있다.

```
argument.length : 인수개수
arguments.callee : 현재 실행되고 있는 함수의 참조
```

Arguments 객체는 '유사 배열 객체'이다.

## 재귀 함수

함수가 자기 자신을 호출하는 행위를 재귀 호출이라고 불리는데 재귀 호출을 수행하는 함수를 재귀 함수라고 한다.

### 재귀 함수의 기본

```
function fact(n){
    if( n <= 1) return 1;
    return n*fact(n-1);
}
fact(5);    // 120
```
재귀 함수를 정의할 때는 다음 두 가지 사항에 유의해야 한다.

- 재귀 호출은 반드시 멈춰야 한다.

- 재귀 호출로 문제를 간단히ㅏ게 해결할 수 있을 때만 사용한다.

## 프로그램의 평가와 실행 과정

### 실행 가능한 코드

자바스크립트 엔진은 실행 가능한 코드를 만나면 그 코드를 평가해서 실행 문맥으로 만든다. 실행 가능한 코드의 유형은 다음과 같다.

- 전역 코드 : 전역 객체 Window 아래에 정의된 함수

- 함수 코드 : 문자 그대로 함수

- eval 코드 : eval 함수

### 실행 문맥의 구성

- 렉시컬 환경 컴포넌트

- 변수 환경 컴포넌트

- 디스 바인딩 컴포넌트

렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 렉시컬 환경 타입의 컴포넌트이다. 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 타입이 같고 with 문을 사용할 때를 제외하면 내부 값이 같으므로 똑같이 취급해도 무리가 없다.

디스 바인딩 컴포넌트는 그 함수를 호출한 객체의 참조가 저장되는 곳이다. 이것이 가리키는 값이 곧 해당 실행 문맥의 this가 된다.

### 렉시컬 환경 콤포넌트의 구성

렉시컬 환경 컴포넌트는 자바스크립트 엔진이 자바스크립트 코드를 실행하기 위해 자원을 모아 둔 곳으로 구체적으로 함수 또는 블록의 유효 범위 안에 있는 식별자와 그 결과값이 저장되는 곳이다. 자바스크립트 엔진은 해당 자바스크립트 코드의 유효 범위 안에 있는 식별자와 그 식별자가 가리키는 값을 키와 값의 쌍으로 바인드해서 렉시컬 환경 컴포넌트에 기록한다.

렉시컬 환경 컴포넌트는 **환경 레코드**와 **외부 렉시컬 환경 참조** 컴포넌트로 구성되어 있다.

환경 레코드는 유효 범위 안에 포함된 식별자를 기록하고 실행하는 영여긍로 ECMAScript 3의 변수 객체와 매우 비슷한 역할을 수행한다. 자바스크립트 엔진은 유효 범위 안의 식별자와 결과값을 바인드해서 환경 레코드에 기록한다.

외부 렉시컬 환경 참조는 함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조가 저장된다. 중첩된 함수 안에서 바깥 코드에 정의된 변수를 읽거나 써야 할 때, 자바스크립트 엔진은 외부 렉시컬 환경 참조를 딸 ㅏ한 단계씩 렉시컬 환경을 거슬러 올라가서 그 변수를 검색한다.

### 환경 레코드의 구성

환경 레코드는 렉시컬 환경 안의 식별자와 그 식별자가 가리키는 값의 묶음이 실제로 저장되는 영역이다. 이 환경 레코드는 선ㅇ너적 호나경 레코드와 객체 환경 레코드로 구성되어 있으며 저장하는 값의 유형에 따라 쓰임새가 달라진다.

#### 선언적 환경 레코드

선언전 환경 레코드는 실제로 함수와 변수, catch 문의 식별자와 실행 결과가 저장되는 영역이다.

#### 객체 환경 레코드

객체 환경 레코드는 실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 쓴다.

### 프로그램의 평가와 전역 변수

자바스크립트 엔진은 전역 코드를 평가할 때 최상위 레벨에 var 문으로 작성한 전역 변수를 전역 환경의 환경 레코드에 프로퍼티로 기록한다. 그 프로퍼티 이름은 식별자 이름이 되고 프로퍼티 값은 undefined가 된다. 함수의 경우에는 최상위 레벨에 작성된 함수 선언문을 함수 객체로 생성해서 전역 환경의 환경 레코드에 프로퍼티로 기록한다.

### 프로그램 실행과 실행 문맥

프로그램이 평가된 다음에는 프로그램이 실행되며, 프로그램은 실행 문맥 안에서 실행된다.

실행 문맥은 스택이라는 구조로 관리된다. 스택이란 일종의 자료 구조로 데이터를 아래에서부터 쌓아 올려서 마지막으로 추가한 데이터를 먼저 꺼내는 '후입선출' 방식으로 관리된다. 스택의 가장 윗부분에 데이터를 쌓는 행위를 push라고 하고, 스택의 가장 윗부분에서 데이터를 빼내는 행위를 pop이라고 한다.

함수의 실행 문맥은 호출될 때마다 스택에 push된다. 그리고 return 문이 실행되어 제어권이 호출한 코드로 돌아가면 스택에서 pop된다. 이러한 이유로 실행 문맥 스택을 호출 스택이라는 이름으로 불린다.

### 자바스크립트는 싱글 스레드

자바 스크립트는 작업을 싱글 스레드로 처리한다. 호출 스택에 쌓인 실행 문맥( 함수 또는 코드)을 위에서부터 아래로 차례차례 실행해 나간다. 그리고 실행 문맥 하나의 작업이 끝나면 pop을 하고 바로 아래에 있는 실행 문맥을 실행한다. 즉, 실행 문맥 단위의 작업을 차례대로 실행하므로 실행 문맥(함수나 코드) 하나의 작업이 끝날 때까지 또 다른 실행 문맥의 작업을 실행하지 않는다. 이느 이벤트 처리와 같은 비동기 처리도 똑같은 방식으로 실행한다.

### 환경 레코드와 지역 변수

함수를 호출하면 현재 실행 중인 코드의 작업을 일시적으로 멈추고 실행 문맥 영역을 생성한다. 그리고 프로그램의 실행 흐름이 그 실행 문맥으로 이동한다. 다음으로 그 함수의 실행 문맥이 호출 스택에 push되고 실행 문맥 안에 렉시컬 환경 컴포넌트를 생성한다.
 이 렉시컬 환경 컴포넌트는 환경 레코드를 가지고 있으며, 환경 레코드 안에 그 함수 안에서 선언 된 중첩 함수의 참조와 변수를 기록한다. 즉, 함수 안팎으 ㅣ호나경을 기록한다.

 ### this 값

 this 값은 '함수가 호출되었을 때 그 함수가 속해 있던 객체의 참조'이며 실행 문맥의 디스 바인딩 컴포넌트가 참조하는 객체이다.

 ```
 var tom = {
    name : "Tom",
    sayHello: function()}{
        console.log("Hello " + this.name);
    }
 };
 ```

 앞의 sayHello 메서드를 호출하면 다음과 같은 결과가 나온다.

 ```
 tom.sayHello();    //Hello! Tom
 ```

 다양한 상황에서 this는 가리키는 것을 정리하자면

1. 최상위 레벨 코드의 this는 전역 객체를 가리킨다. 실행 문맥이 초기화될 때 그 안의 디스 바인딩 컴포넌트가 전역 환경을 가리키도록 초기화되기 때문이다.

2. 이벤트 처리기 안에 있는 this는 이벤트가 발생할 요소 객체를 가리킨다.

3. ㅅ생성자 함수 안에 있는 this는 그 생성자로 생성한 객체를 가리킨다.

4. 생성자의 prototype 메서드 안에 있는 this는 그 생성자로 생성한 객체를 가리킨다. 

5.  직접 호출한 함수 안에 있는 this는 함수를 최상위 레벨의 코드에서 호출하면 전역 객체를 가리킨다.

```
function f(){console.log(this);}
f();
```

함수 앞에 어떤 객체를 붙여서 호출하면 디스 바인딩 컴포넌트가 그 객체를 가리킨다.

```
function f(){console.log(this);}
f();
```
6. apply와 call 메서드를 사용하면 함수를 호출할 때 this가 가리키는 객체를 바꿀 수 있다.

### 식별자 결정 : 유효 범위 체인

변수를 선언하면 그 안쪽에 있는 코드 전체가 그 변수를 사용할 수 있는 유효 범위가 된다.

### 가비지 컬렉션

프로그램에서 객체를 생성하면 메모리 공간이 동적으로 확보된다. 사용하지 않는 객체의 메모리 영역은 가비지 컬렉터가 자동으로 해제한다.