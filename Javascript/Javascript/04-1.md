# 객체의 기초

## 객체 리터럴

### 객체

객체는 이름과 같은 한 쌍으로 묶은 데이터를 여러 개 모은 것이다. 즉, 객체는 데이터 여러 개를 하나로 모은 복합 데이터로 연관 배열 또는 사전이라고 부른다. 

객체에 포함된 데이터 하나(이름과 값의 쌍)를 가리켜 객체의 프로퍼티라고 부른다. suit와 rank는 프로퍼티이며 프로퍼티의 이름 부분을 **프로퍼티** 이름 또는 **키라**고 부른다.

자바 스크립트에서는 객체를 생성하는 방법은 두 가지이다. 하나는 객체 리터럴을 사용하는 방법이고 나머지 하나는 생성자라는 함수를 사용하는 방법이다. 이 절에는 객체 리터럴을 사용하여 객체를 생성하는 방법을 배운다.

## 객체 리터럴로 객체 생성하기

아래가 객체 리터럴의 예시이다.

```
var card = { suit:"하트", rank: "A"};
```

{..} 부분이 바로 객체 리터럴이며, 객체 리터럴을 변수 card에 대입하고 있다. 프로퍼티 이름과 프로퍼티 값은 suit: "하트"처럼 콜론(:)을 사용해서 구분하며, 중괄호({}) 안에 있는 프로퍼티들은 쉼표(,)로 구분한다. 프로퍼티 이름으로 모든 식별자와 문자열 리터럴(빈 문자열도 사용 가능)을 사용할 수 있다. 즉, 앞 코드에 있는 프로퍼티 이름은 문자열로 바꾸어 작성할 수 있다.

```
var card = {"suit":"하트", 'rank':"A"};
```
프로퍼티 값에는 모든 데이터 타입의 값과 표현식을 대입할 수 있다.
변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 마침표(.) 연산자 또는 대괄호([])연산자를 사용한다.

```
card.suit       // 하트
card["rank"]    //A
```

여기에 마침표 다음에 문자열이 붙어 있지 않다는 점과 대괄호 안이 문자열로 채워져 있다는 점을 주목해야 한다. 마침표로 프로퍼티를 읽거나 쓸 때는 프로퍼티 이름 즉, 식별자만 사용할 수 있다. 대괄호로 프로퍼티를 읽거나 쓸 때는 프로퍼티 이름 또는 문자열을 반환하는 표현식을 사용할 수 있다.
객체에 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환한다.

```
card.color  //undefined
```
선언되지 않은 변수를 읽으려고 시도하면 참조 오류가 발생하는 것과는 대조적이다. 객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성된다.

```
var obj = {};
console.log(obj);   // Object{}
```

### 프로퍼티 추가와 삭제

없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가된다.

```

card.value = 14;
console.log(card);  //Object {suit: "하트", rank: "A", value: 14}
```

delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.

```

delete card.rank;
console.log(card);  // Object {suit: "하트", value: 14}

```

이처럼 자바스크립트의 객체는 실행 중에 프로퍼티를 자유롭게 추가하거나 삭제할 수 있다. 반면 Java와 C++ 등에서는 객체의 프로퍼티를 실행 중에 추가하거나 삭제할 수 없다.

## in 연산자로 프로퍼티가 있는지 확인하기

in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있다.

```

프로퍼티 이름을 뜻하는 문자열 in 객체명

```

아래의 예시

```

var card = {suit: "하트", rank: "A"};
console.log("suit" in card);    // true
console.log("color" in card);   // false

```

앞 코드에서 in 연산자가 조사하는 대상이 그 객체가 가진 프로퍼티와 그 객체가 상속받은 모든 프로퍼티라는 점을 주의한다. 원래 toString 프로퍼티는 card 객체 안에 없지만 다음 코드를 보면 toString 프로퍼티가 card에 있다는 결과가 나온다.

```
console.log("toString" in card);    //true
```
이는 card가 Object 객체를 상속받았기 때문이다.

### 메서드

메서드는 프로퍼티에 저장된 값의 타입이 함수면 그 프로퍼티를 메서드라고 부른다.

### 객체는 참조 타입

생성된 객체는 메모리의 영역을 차지하는 한 덩어리가 된다. 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 **참조**가 저장된다. 이때의 변수 상태를 가리켜 그 객체를 **참조하고 있다**라고 한다.

# 함수

수학에서의 함수는 주어진 입력 값 x에 대해 출력 값 t를 댕으시키는 규칙이다.
예를 들자면 함수 이름을 f라고 할 때, 함수 값인 y는 f(x)라고 쓴다.

자바스크립트의 함수가 수학 함수와 다른 점은 입력을 받은 후에 함수 안의 프로그램에서 특정 작업을 수행한다는 점이다. 자바스크립트에서는 함수의 입력 값을 인수라고 부르고 함수의 출력 값을 반환값이라고 부른다.

## 함수 선언문으로 함수 정의하기

함수는 function 키워드를 사용해서 정의한다.

```
function sqaure(x) {return x * x;}
```

이 함수는 인수의 제곱을 계싼해서 반환한다. 이 코드에서는 소괄호 안에 있는 x가 인수고 중괄호 안에 있는 코드가 함수가 실행하는 작업이다. return 문이 실행되면 제어권이 함수를 호출한 코드로 되돌아가고, return 문에 지정된 값(앞 코드에서는 x * x: x와 x의 곱)은 함수의 반환값이 된다.

### 함수의 이름

모든 식별자를 함수 이름으로 사용할 수 있다. 단, 함수 이름은 해당 함수의 기능을 이해하기 쉽게 지어야 한다. 함수에 이름을 잘 붙이면 주석을 보질 않거나 파악할 수 있으므로 프로그램의 가독성과 유지 보수성이 크게 높아진다. 함수 이름은 일반적으로 동사 또는 동사로 시작되는 어휘로 만든다.

### 함수 호출

함수를 호출하려면 함수 이름 뒤에 소괄호로 인수를 묶어 입력한다.

```
square(3)

function square(x){
    return x * x;
}
```

square의 값을 3으로 지정했을 때, 인수로 넘긴 값인 3이 함수 정의문이 인수 x로 전달되고, 중괄호 안에 작성된 코드를 실행한다. 그리고, return 뒤에 있는 인수 x와 뒤에 * 인수 x로 연산되어져서, 결과적으로 return 문의 값인 9가 함수의 반환값이 된다. 이때 함수를 호출할 때 전달하는 값을 인수, 함수 정의문의 인수를 인자라고 부른다.

### 인수

함수는 인수를 여러 개 받을 수 있다. 인수가 여러 개라면 인수와 인수를 쉼표(,)로 구분한다. 예를 들어 다음 한다.

### 함수의 실행 흐름

일반적인 함수의 실행 흐름은 다음과 같다.

- 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다.

- 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다.

- return 문이 실행되면 호출한 코드로 돌아간다. return 문의 값은 함수의 반환값이 된다.

- return 문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후에 undefined가 함수의 반환값이 된다.

### 변수의 유효 범위

변수에 접근할 수 있는 범위를 그 변수의 **유효 범위**라고 한다. 유효범위를 결정하는 두 가지로는 프로그램의 구문만으로 유효 범위를 정하는 **어휘적 범위**고 남은 하나는 프로그램 실행 중에 유효 범위를 정하는 **동적 범위**다. 자바스크립트도 어휘적 범위를 채택하고 있다. 자바스크립트 변수는 유효 범위에 따라 **전역 변수**와 **지역 변수**로 나뉜다.

전역 변수는 함수 바깥에서 선언된 변수로 유효 범위가 전체 프로그램이다. 지역 변수는 함수 안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부이다.

#### 변수의 충돌

변수에 유효 범위가 있는 이유는 프로그램의 다른 부분에서 선언된 이름이 같은 변수와 충돌하지 않도록 하기 위해서이다. 다른 함수 내부에서 선언된 각각의 지역 변수는 모두 선언된 함수 내부에서만 유효하므로 이름이 같아도 충돌하지 않는다. 덕분에 함수 안에서 변수 이름을 지을 때는 다른 함수 안에서 사용하는 변수 이름까지 신경 쓸 필요가없다.
 하지만, 전역 변수 이름과 지역 변수 이름이 같아지면 두 변수가 충돌하는데, 이때는 전역 변수를 숨기고 지역 변수를 사용하게 된다.

### let과 const

let과 const는 ECMAScript 6부터 추가된 변수 선언자로 모두가 '블록 유효 범위'를 갖는 변수를 선언한다. 블록 유효 범위를 가진 변수는 중괄호({}) 안에서만 유효하다. let은 변수를 선언하고 const는 한 번만 할당할 수 있는 상수를 선언한다.

#### let선언자

let 문은 블록 유효 범위를 갖는 지역 변수를 선언한다. 사용법은 var과 같지만 var과의 차이점은 let으로 선언한 변수의 유효 범위가 블록 안이다. 이는 var이 let이 등장하기 이전에는 중복 선언이 가능했었고 에러가 나지 않는다는 장점이 있었으나 유연한 변수 선언이 가능하다고 하기엔 중복 선언의 위험이 더 컸다. 이런 문제를 보완하기 위해서 let이 추가되었다.

#### const 선언자

const 문은 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언한다. const로 선언한 상수는 let 문으로 선언한 변수처럼 동작한다. 단, 반드시 초기화해야 한다는 차이점이 있다.

### 함수 리터럴로 함수 정의하기

**함수 리터럴**은 이름이 없는 함수이므로 **익명 함수** 또는 **무명 함수**라고 부른다. 함수 선언문에서는 끝에 세미콜론을 붙일 필요가 없지만 함수 리터럴을 사용할 때는 끝에 반드시 세미콜론을 붙여야 한다. 함수 선언문으로 정의한 함수와 함수 리터럴로 정의한 함수의 사용법은 같다.

### 객체의 메서드

객체의 프로퍼티 중에서 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 메서드라고 부른다. 메서드를 정의할 때는 프로퍼티 함수 리터럴을 대입한다.

### 함수를 활용하면 얻을 수 있는 장점

#### 재사용할 수 있다.

똑같은 작업을 여러 번 박복해야 할 때  함수 하나로 만들어 두면, 함수 호출만으로도 같은 작업을 여러 번 반복 할 수 있다.

#### 만든 프로그램을 이해하기 쉽다.

함수를 사용하면 일정한 처리를 모아서 이름을 붙일 수 있다. 이는 함수 안에 상세한 내용을 숨기는 효과가 있다. 따라서 프로그램을 읽을 때 프로그램의 큰 흐름을 쉽게 파악할 수 있다.

#### 프로그램 수정이 간단해진다.

함수를 사용하지 않으면 똑같은 처리를 프로그램 곳곳에 작성해야 하기 때문에 시간이 오래걸리게 되지만 함수로 정리해 두면 해당 함수만 수정하면 되므로 수정이 간단해진다.